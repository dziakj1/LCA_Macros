   /*-----------------------------------------------------------------*
   | The documentation and code below is supplied by The Methodology              
   | Center, Penn State University.             
   *------------------------------------------------------------------*                          
  /*------------------------------------------------------------------*
   | MACRO NAME  : %LCA_Distal_BCH version 1.1.0
   | SHORT DESC  : Estimate a distal outcome for a single or multiple 
   |               groups based on prior latent class membership,
   |               using the method of Bolck, Croon, and Hagenaar (2004;
   |               see also Vermunt, 2010)
   | REQUIREMENTS: SAS v 9.1 or higher and PROC LCA v 1.2.6 or higher
   *------------------------------------------------------------------*
   | CREATED BY  : John J. Dziak and Bethany C. Bray (May 1, 2017)  
   |               based partly on LCA_Distal_v302 software by Jingyun Yang, 
   |               Xianming Tan, and John J. Dziak (earlier version May 9, 2016)
   | CONTACT :  Methodology Center Helpdesk (MChelpdesk@psu.edu)
   *------------------------------------------------------------------*
   | Copyright 2017, The Pennsylvania State University
   |
   | This software is distributed "as is" without any warranty.   
   | All warranties, including, but not limited to, implied 
   | warranties of merchantability and fitness for a particular.
   | purpose, are disclaimed.
   *------------------------------------------------------------------*   
   | Required arguments in %LCA_distal:
   |     input_data:          The input data  
   |     param:               The OUTPARAM file generated by PROC LCA
   |     post:                The OUTPOST file generated by PROC LCA
   |     distal:              The distal outcome variable in the dataset
   |     metric:              Within-class metric assumed for the distal 
   |                          outcome.  This may be the word "binary", 
   |                          "categorical," "count," "or "numerical,"  
   |                          without quotes.  
   | Optional arguments in %LCA_distal:
   |     group:               The variable distinguishing multiple groups
   |     adjustment_method:   BCH (default, recommended) or unadjusted
   |     assignment:          modal (default) or proportional
   |     alpha:               One minus coverage for confidence intervals to be
   |                          generated; default is 0.05.
   |     sampling_weight:     Name of the survey weighting variable.  Must be 
   |                          specified if survey weights are to be used. 
   *--------------------------------------------------------------------*
   | Notes:
   | 1. In the specific case of proportionally weighted unadjusted estimates,
   |    this macro appears to calculate covariance differently from Latent GOLD.
   | 2. This macro has the following structure.   Macro LCA_Distal_BCH is 
   |    called first.  It is accompanied by a helper macro called 
   |    Distal_Nogroup_BCH, which it calls one or more times.  In turn, 
   |    Distal_Nogroup_BCH contains a helper function called 
   |    Estimate_Distal_Mean_And_SE, which it uses one or more times.
   *--------------------------------------------------------------------*
   | References:
   | Bolck, A., Croon, M., & Hagenaars, J. (2004). Estimating latent 
   |   structure models with categorical variables: One-step versus 
   |   three-step estimators. Political Analysis, 12(1), 3-27.  
   | Lanza, S.T., Collins, L.M., Lemmon, D.R., & Schafer, J.L. (2007). 
   |   PROC LCA: A SAS procedure for latent class analysis. Structural 
   |   Equation Modeling, 14: 671-694.
   | Vermunt, J. K. (2010). Latent class modeling with covariates: Two 
   |   improved three-step approaches, Political Analysis, 18, 450-469. 
   *--------------------------------------------------------------------*/

%MACRO LCA_Distal_BCH( input_data ,    
                       param ,      
                       post ,  
                       id ,
                       distal ,     
                       metric = numerical, 
                       adjustment_method = BCH,
                       assignment = modal,
                       group = ,      
                       alpha = .05,
                       sampling_weight = );      
    /* Create some empty datasets to hold the results (or erase existing results datasets). */ 
    DATA _estimates_this_group; RUN;
    DATA _tests_this_group; RUN;            
    DATA _sortedinput; RUN;                       
    /* Error checking for input parameters:  Check for blank required arguments. */
        PROC IML;
            %IF %TRIM("&input_data")="" %THEN %DO;
                PRINT "Error :  A dataset for input_data must be provided.";
            %END;     
            %IF %TRIM("&param")="" %THEN %DO;
                PRINT "Error :  A dataset for param must be provided.";
            %END;     
            %IF %TRIM("&post")="" %THEN %DO;
                PRINT "Error :  A dataset for post must be provided.";
            %END;     
            %IF %TRIM("&id")="" %THEN %DO;
                PRINT "Error :  A variable for id must be provided.";
            %END;     
            %IF %TRIM("&distal")="" %THEN %DO;
                PRINT "Error :  A variable for distal must be provided.";
            %END;     
        QUIT;
    /* Remove cases with missing data */
        DATA _input_nomiss;
            SET &input_data ;
            WHERE &distal IS NOT MISSING;
        RUN;
        DATA _temp_data;
            SET &input_data;
            KEEP &id &distal &sampling_weight;
        RUN;
        DATA &post;
            MERGE &post _temp_data;
            BY &id;
        RUN;
        DATA _post_nomiss;
            SET &post;
            WHERE ((&distal IS NOT MISSING)&(&id IS NOT MISSING)&(postlc1 IS NOT MISSING)
                %IF %TRIM("&sampling_weight")="" %THEN %DO; %END; %ELSE %DO;
                    &(&sampling_weight IS NOT MISSING)
                %END;
                )
            ;
        RUN;
    /* Read and Record the Input Argument:  metric*/
        PROC IML; 
            is_binary = 0; 
            is_categorical = 0;
            is_count = 0;
            is_continuous = 0;
            IF (UPCASE(STRIP("&metric")) = "BINARY") THEN DO;
                is_binary = 1;                
                USE _input_nomiss;
                    READ ALL VAR {&distal} INTO Z;
                    IF ((Z=0)[+] + (Z=1)[+] < NROW(Z)) THEN DO;
                        PRINT "Error :  Please code a binary distal outcome as 0 for no and 1 for yes.";
                    END;
                CLOSE _input_nomiss;  
            END; 
            IF ((UPCASE(STRIP("&metric")) = "BINARY")|
                (UPCASE(STRIP("&metric")) = "LOGISTIC")) THEN DO;
                is_binary = 1;
            END; 
            IF ((UPCASE(STRIP("&metric")) = "CATEGORICAL")|
                (UPCASE(STRIP("&metric")) = "NOMINAL")) THEN DO;
                is_categorical = 1;
            END; 
            IF ((UPCASE(STRIP("&metric")) = "COUNT")|
                (UPCASE(STRIP("&metric")) = "POISSON") ) THEN DO;
                is_count = 1;
            END; 
            IF ((UPCASE(STRIP("&metric")) = "CONTINUOUS")|
                (UPCASE(STRIP("&metric")) = "NORMAL")|
                (UPCASE(STRIP("&metric")) = "NUMERICAL") )    THEN DO;
                is_continuous = 1;
            END;  
            IF (is_binary + is_categorical + is_count + is_continuous ^= 1) THEN DO;
                PRINT "Error :  Could not recognize option specified for metric.";
            END;
            CALL SYMPUT("is_binary", CHAR(is_binary));  
                /* SYMPUT saves a macro variable to be read later. */
            CALL SYMPUT("is_categorical", CHAR(is_categorical)); 
            CALL SYMPUT("is_count", CHAR(is_count)); 
            CALL SYMPUT("is_continuous", CHAR(is_continuous)); 
        QUIT;
    /* Read and Record the Input Argument: adjustment_method */
    /* Usually, the user will want to use the BCH adjustment, which is very 
       accurate most of the time.  However, the BCH adjustment occasionally 
       gives an unreasonable answer (e.g., a negative count or probability), 
       so then the user might want to use the naive (unadjusted) version which 
       is more conservative. */
        PROC IML; 
            is_naive_adjustment_method    = 0;
            IF ((UPCASE(STRIP("&adjustment_method")) = "UNADJUSTED")|
                (UPCASE(STRIP("&adjustment_method")) = "NAIVE") )    THEN DO;
                is_naive_adjustment_method = 1;
            END;  
            CALL SYMPUT("is_naive_adjustment_method", CHAR(is_naive_adjustment_method)); 
        QUIT;    
    /* Read and Record the Input Argument: assignment */
        PROC IML; 
            is_proportional_assignment    = 0;
            IF ((UPCASE(STRIP("&assignment")) = "PROPORTIONAL"))    THEN DO;
                is_proportional_assignment = 1;
            END;  
            CALL SYMPUT("is_proportional_assignment", CHAR(is_proportional_assignment)); 
        QUIT;    
    /* Read and Record the Input Argument:  group */
        %IF %TRIM("&group")="" %THEN %DO;
            %LET there_are_groups = 0;
        %END; %ELSE %DO;
            %LET there_are_groups = 1; 
        %END;      
        %IF %EVAL((&is_count=1)|(&is_continuous=1)) %THEN %DO;
            TITLE2 "BCH Estimation of Means of &distal by Latent Class";
        %END; %ELSE %DO;
            TITLE2 "BCH Estimation of Proportions of &distal by Latent Class";
        %END;                
        %IF %EVAL(&there_are_groups=1) %THEN %DO; 
            /* Sort the data according to group, and separate into multiple datasets. */
            PROC SQL;
                RESET NOPRINT;
                SELECT unique group into :all_group separated by ' '
                FROM &param;
                RESET PRINT;
            QUIT;  
            PROC SORT DATA=_input_nomiss OUT=_sortedinput;
                BY &group;
            RUN;   * sort the input data by group;
            PROC SORT DATA=_post_nomiss OUT=_sortedpost;
                BY &group;
            RUN;   * sort the input data by group;
            %LET group_num =%EVAL(%SYSFUNC(count(%cmpres(&all_group),%STR( )))+1);
                       /* the total number of groups; */  
            %DO i=1 %TO &group_num;
                DATA _subset_input_group&i;
                    SET _sortedinput;
                    IF &group=&i;
                RUN;
                DATA _subset_param_group&i;
                    SET &param;
                    IF GROUP=&i;
                RUN;
                DATA _subset_post_group&i;
                    SET _sortedpost;
                    IF &group=&i;
                RUN; 
                TITLE3 "For Group &i of &group_num on Variable &group"; 
                %Distal_NoGroup_BCH(the_data = _subset_input_group&i,
                                    param = _subset_param_group&i,
                                    post = _subset_post_group&i,
                                    distal = &distal,
                                    is_binary = &is_binary,
                                    is_categorical = &is_categorical,
                                    is_continuous = &is_continuous,
                                    is_count = &is_count,
                                    is_naive_adjustment_method = &is_naive_adjustment_method,
                                    is_proportional_assignment = &is_proportional_assignment,
                                    alpha = &alpha,
                                    sampling_weight = &sampling_weight );
                DATA _estimates_this_group; SET _estimates_this_group; &group = &i; RUN;
                DATA _tests_this_group; SET _tests_this_group; &group = &i; RUN; 
                %IF %EVAL(&i = 1) %THEN %DO;
                    DATA Distal_Estimates; SET _estimates_this_group; RUN;
                    %IF %EVAL(&is_binary=1) %THEN %DO;
                        DATA Distal_LogOdds; SET _log_odds_this_group; RUN;
                    %END;
                    DATA Distal_Tests; SET _tests_this_group; RUN;
                %END; %ELSE %DO; 
                    DATA Distal_Estimates; SET Distal_Estimates _estimates_this_group; RUN;
                    %IF %EVAL(&is_binary=1) %THEN %DO;
                        DATA Distal_LogOdds; SET Distal_LogOdds _log_odds_this_group; RUN;
                    %END;
                    DATA Distal_Tests; SET Distal_Tests _tests_this_group; RUN;
                %END; 
            %END;
        %END; %ELSE %DO;
            %LET group = _GroupForMacro_;
            DATA _sortedinput;
                SET _input_nomiss;
                _GroupForMacro_ = 1;
            RUN;
            TITLE3;  
            %Distal_NoGroup_BCH( the_data = _sortedinput,
                                 param = &param,
                                 post = _post_nomiss,
                                 distal = &distal,
                                 is_binary = &is_binary,
                                 is_categorical = &is_categorical,
                                 is_continuous = &is_continuous,
                                 is_count = &is_count,
                                 is_naive_adjustment_method = &is_naive_adjustment_method,
                                 is_proportional_assignment = &is_proportional_assignment,
                                 alpha = &alpha,
                                 sampling_weight = &sampling_weight );
            DATA Distal_Estimates; SET _estimates_this_group; RUN;
            %IF %EVAL(&is_binary=1) %THEN %DO;
                DATA Distal_LogOdds; SET _log_odds_this_group; RUN;
            %END;
            DATA Distal_Tests; SET _tests_this_group; RUN;
        %END;
        TITLE2; TITLE3; TITLE4;
        PROC DATASETS NOLIST NOWARN;
            DELETE _BCH_weights_this_group _CovarianceBetaThisGroup
                   _GroupForMacro_ _Unadjusted_Weights_This_Group 
                   _estimates_this_group _input_nomiss
                   _log_odds_this_group _post_nomiss _sortedinput
                   _sortedpost _temp_data _tests_this_group;
        QUIT; RUN;
%MEND LCA_Distal_BCH; 

%MACRO Distal_NoGroup_BCH(the_data,
                          param,
                          post,
                          distal,
                          is_binary,
                          is_categorical,
                          is_continuous,
                          is_count,
                          is_naive_adjustment_method,
                          is_proportional_assignment,
                          alpha,
                          sampling_weight); 
    PROC IML;
        START Estimate_Distal_Mean_And_SE(num_classes,  /* this is an input */
                                            N,  /* this is an input */
                                            weights,  /* this is an input */
                                            Z,  /* this is an input */
                                            is_identity_link, /* this is an input */
                                            is_log_link, /* this is an input */
                                            is_logit_link, /* this is an input */
                                            Linear_Predictor,  /* this is an output */
                                            Std_Err_Linear_Predictor, /* this is an output */
                                        Cov_Matrix_Linear_Predictor); /* this is an output */ 
                /* Note:  For our purposes, in generalized linear models, 
                          identity link corresponds to continuous outcome,
                          log link corresponds to count outcome, 
                          and logit link corresponds to binary outcome.
                          Categorical outcome is more complicated and is dealt with elsewhere.
                          However, when calculating standard errors for probabilities, we follow
                          Latent GOLD 5.1 in using an identity link for continuous, count OR 
                          binary outcomes. */
                /* Note:  This is a very unusual case of generalized linear modeling in which
                the design matrix X is actually just the identity matrix.  That is because the 
                mean for each class is related only to the mean parameter for that class.  In 
                other words, we just have a bunch of different class-specific intercepts and 
                no other covariates. */
            Distal_Mean = J(num_classes,1,.);
            DO c = 1 TO num_classes;
                Distal_Mean[c] = ((weights[,c]#Z)[+])/(weights[+,c]);
                /* This is the weighted average of the distal outcome variable Z, using 
                the weights in weights[,c].  The symbol # is elementwise multiplication 
                and the symbol + means sum over a dimension.  So it is the sum of crossproducts 
                of weight and Z, divided by the sum of weight.  That is the definition
                of a weighted average. */                
            END; 
            IF is_identity_link=1 THEN DO;
                Linear_Predictor = Distal_Mean;
            END;
            IF is_log_link=1 THEN DO;
                Distal_Mean = 1e-15 <> Distal_Mean;  /* note that <> means elementwise maximum */
                Linear_Predictor = LOG(Distal_Mean);
            END;
            IF is_logit_link=1 THEN DO; 
                Distal_Mean = 1e-15 <> Distal_Mean;
                Distal_Mean = .999999999999999 >< Distal_Mean;   /* note that >< means elementwise minimum */
                Linear_Predictor = LOG(Distal_Mean/(1-Distal_Mean+1e-30));
            END;              
            Empirical_Cov_Z = J(num_classes,num_classes,0);
            DO i = 1 TO N;
                ThisSubjectsResiduals = J(num_classes,1,0);
                DO c = 1 TO num_classes;
                    ThisSubjectsResiduals[c] = (weights[i,c])*(Z[i]-Distal_Mean[c]);
                END;
                Empirical_Cov_Z = Empirical_Cov_Z + ThisSubjectsResiduals*ThisSubjectsResiduals`;
            END; 
            Inv_Diag_Sum_Weights = J(num_classes,num_classes,0);
            DO c = 1 TO num_classes;
                IF is_identity_link=1 THEN DO;
                    Inv_Diag_Sum_Weights[c,c] = 1/((weights[,c])[+]);
                END;
                IF is_log_link=1 THEN DO;
                    Inv_Diag_Sum_Weights[c,c] = 1/((weights[,c]#Distal_Mean[c])[+]);
                END;
                IF is_logit_link=1 THEN DO;
                    Inv_Diag_Sum_Weights[c,c] = 1/((weights[,c]#Distal_Mean[c]#(1-Distal_Mean[c]))[+]);
                END;
            END;
            Cov_Matrix_Linear_Predictor = ((num_classes*N)/(num_classes*N-num_classes))*Inv_Diag_Sum_Weights*Empirical_Cov_Z*Inv_Diag_Sum_Weights;
            Std_Err_Linear_Predictor = SQRT(VECDIAG(Cov_Matrix_Linear_Predictor)); 
        FINISH Estimate_Distal_Mean_And_SE;
        StatusOkay = 1;
		CritVal = PROBIT (1-&alpha/2);
        /* Read and Record the Input Argument:  sampling_weight*/
        %IF %TRIM("&sampling_weight")="" %THEN %DO;
            there_are_sampling_weights = 0;
        %END; %ELSE %DO;
            there_are_sampling_weights = 1; 
        %END;      
        /* Read the parameter information in from the param dataset. */
        USE &param;
            READ ALL INTO gamma WHERE (param="GAMMA"); 
        CLOSE &param; 
        num_classes = NCOL(gamma) - 2; /* Number of classes. The first two columns are indices. */
        CALL SYMPUT("num_classes",CHAR(num_classes));
        IF (num_classes<1) THEN DO;
            PRINT "Problem detected with the &param dataset: No classes found";
            StatusOkay = 0;
        END; 
        gamma = gamma[3:(num_classes+2)];  
        /* Read the posterior probabilities in from the post dataset. */
        ColumnNames = (TRANWRD(ROWCATC(CONCAT("PostLC", (CHAR(1:&num_classes)))),"PostLC"," PostLC")); 
            /* see http://blogs.sas.com/content/iml/2015/07/27/vector-to-string.html */
        CALL SYMPUT("ColumnNames",ColumnNames);
        USE &post;
            READ ALL VAR {&ColumnNames} INTO postprobs;
            READ ALL VAR {&distal} INTO Z;
            IF there_are_sampling_weights THEN DO;
                READ ALL VAR {&sampling_weight} INTO sw;
            END;
        CLOSE &post;  
        N = NROW(postprobs);   /* sample size */ 
        is_proportional_assignment = &is_proportional_assignment;
        IF (is_proportional_assignment = 1) THEN DO;
            Unadjusted_Weights = postprobs;
        END; ELSE DO;
            modal = postprobs[,<:>];  /* vector of indices of highest posterior probability for each subject */
            /* Calculate the modal weights using the unadjusted (naive) approach. */
            Unadjusted_Weights = J(N,num_classes,.);
            DO i = 1 TO N;
                DO c = 1 TO num_classes;
                    Unadjusted_Weights[i,c] = 1*(modal[i]=c);
                END;
            END;
        END;
        IF there_are_sampling_weights THEN DO; 
            DO c = 1 TO num_classes;
                Unadjusted_Weights[,c] = Unadjusted_Weights[,c] # sw;
            END;
        END;
        CREATE _Unadjusted_Weights_This_Group FROM Unadjusted_Weights;
            APPEND FROM Unadjusted_Weights;
        CLOSE _Unadjusted_Weights_This_Group;                    
        /* Convert the unadjusted weights into BCH weights. */            
        D = J(num_classes,num_classes,.);
        DO t = 1 TO num_classes;
            DO s = 1 TO num_classes;
                D[t,s] = SUM(Unadjusted_Weights[,s]#postprobs[,t])/(N*gamma[t]);
            END;
        END;
        /* D[t,s] = P(assigned=s | true=t] */ 
        Dinv = INV(D);
        DinvT = Dinv`;
        BCH_Weights = Unadjusted_Weights*Dinv;  
        CREATE _BCH_weights_this_group FROM BCH_Weights;
            APPEND FROM BCH_Weights;
        CLOSE _BCH_weights_this_group;
        /* Decide which adjustment_method to use. */
        %IF %EVAL(&is_naive_adjustment_method=1) %THEN %DO;
            /* If the user insists, we can use unadjusted weights... */
            Chosen_Weights = Unadjusted_Weights;
        %END; %ELSE %DO;
            /* ... but the main point of the macro is to use BCH weights because
            they usually give more accurate results. */
            Chosen_Weights = BCH_Weights;
        %END;
        /* Calculate the estimates and standard errors using the chosen weights. 
           For continuous and count data, we will use the identity link to get
           estimates and standard errors, just as Latent GOLD does, even though
           for testing we will not use the identity link for count but the log 
           link instead.             
        */            
        %IF %EVAL(&is_continuous=1 | &is_count=1) %THEN %DO; 
            Class = 1:num_classes; 
            Distal_Mean = J(num_classes,1,.); 
            Distal_Std_Error_For_Mean = J(num_classes,1,.);
            Cov_Matrix_Linear_Predictor= J(num_classes,num_classes,.);                
            CALL Estimate_Distal_Mean_And_SE( num_classes,  /* input */
                                                N,  /* input */
                                                Chosen_Weights,  /* input */
                                                Z,  /* input */
                                                1, 0, 0, /* treat as identity link for purposes of getting 
                                                            direct estimates and symmetric standard errors 
                                                            for the expected values; this is statistically
                                                            inefficient but asymptotically valid and roughly
                                                            follows the approach of Latent GOLD. */
                                                Distal_Mean,  /* output */
                                                Distal_Std_Error_For_Mean, /* output */
                                                Cov_Matrix_Linear_Predictor); 
            %IF %EVAL(&is_count=1 ) %THEN %DO;
                IF (SUM(Distal_Mean<0)>0) THEN DO;
                    Distal_Mean[LOC(Distal_Mean<0)] = 0;
                    Distal_Std_Error_For_Mean[LOC(Distal_Mean<0)] = .;
                END;
            %END;            
            Distal_CI_Upper = Distal_Mean + CritVal*Distal_Std_Error_For_Mean;
            Distal_CI_Lower = Distal_Mean - CritVal*Distal_Std_Error_For_Mean;
            CREATE _estimates_this_group VAR {
                Class Distal_Mean Distal_Std_Error_For_Mean  Distal_CI_Lower Distal_CI_Upper
            }; APPEND;
            CLOSE _estimates_this_group;
        %END;                
        /* For binary data, we will first use the identity link (get 
        standard errors treating the probability as the mean of a list 
        of 0's and 1's) and then use the logit link (get asymmetric 
        confidence intervals treating the probability as the output 
        of a logistic regression model). */
        %IF %EVAL(&is_binary=1 ) %THEN %DO; 
            Class = 1:num_classes;               
            /* Get estimates and standard errors for probabilities (treated as means 
               of dummy variables) */
            Distal_Prob = J(num_classes,1,.); 
            Distal_Std_Error_For_Prob = J(num_classes,1,.);
            Cov_Matrix_Distal_Probs= J(num_classes,num_classes,.);  
            CALL Estimate_Distal_Mean_And_SE( num_classes,  /* input */
                                                N,  /* input */
                                                Chosen_Weights,  /* input */
                                                Z,  /* input */
                                                1, 0, 0, /* treat as identity link for purposes of getting 
                                                            direct estimates and symmetric standard errors 
                                                            for the expected values; this is statistically
                                                            inefficient but asymptotically valid and roughly
                                                            follows the approach of Latent GOLD. */
                                                Distal_Prob,  /* output */
                                                Distal_Std_Error_For_Prob, /* output */
                                                Cov_Matrix_Distal_Probs); 
            IF (SUM(Distal_Prob<0)>0) THEN DO;
                Distal_Prob[LOC(Distal_Prob<0)] = 0;
                Distal_Std_Error_For_Prob[LOC(Distal_Prob<0)] = .;
            END;
            IF (SUM(Distal_Prob>1)>0) THEN DO;
                Distal_Prob[LOC(Distal_Prob>1)] = 1;
                Distal_Std_Error_For_Prob[LOC(Distal_Prob>1)] = .;
            END;
            Distal_CI_Upper = Distal_Prob + CritVal*Distal_Std_Error_For_Prob;
            Distal_CI_Lower = Distal_Prob - CritVal*Distal_Std_Error_For_Prob;
            IF (SUM(Distal_CI_Upper>1)>0) THEN Distal_CI_Upper[LOC(Distal_CI_Upper>1)] = 1;
            IF (SUM(Distal_CI_Lower<0)>0) THEN Distal_CI_Lower[LOC(Distal_CI_Upper<0)] = 0;            
            CREATE _estimates_this_group VAR {
                Class Distal_Prob Distal_Std_Error_For_Prob Distal_CI_Lower Distal_CI_Upper
            }; APPEND;
            CLOSE _estimates_this_group;
            /* Get estimates of log odds and asymptotic confidence intervals for probabilities
               (using the logistic link). */
            Distal_Log_Odds = J(num_classes,1,.); 
            Distal_Std_Error_For_Log_Odds = J(num_classes,1,.);
            Cov_Matrix_Log_Odds = J(num_classes,num_classes,.);  
            CALL Estimate_Distal_Mean_And_SE(num_classes,  /* input */
                                                N,  /* input */
                                                Chosen_Weights,  /* input */
                                                Z,  /* input */
                                                0, 0, 1, /* now correctly treat as binary. */
                                                Distal_Log_Odds,  /* output */
                                                Distal_Std_Error_For_Log_Odds, /* output */
                                                Cov_Matrix_Log_Odds); 
            Distal_Probability = EXP(Distal_Log_Odds)/(1+EXP(Distal_Log_Odds));
            CI_Lower_Log_Odds = Distal_Log_Odds - CritVal*Distal_Std_Error_For_Log_Odds;
            CI_Upper_Log_Odds = Distal_Log_Odds + CritVal*Distal_Std_Error_For_Log_Odds;
            CI_Lower_Probability = EXP(CI_Lower_Log_Odds)/(1+EXP(CI_Lower_Log_Odds));
            CI_Upper_Probability = EXP(CI_Upper_Log_Odds)/(1+EXP(CI_Upper_Log_Odds));
            CREATE _log_odds_this_group VAR {
                Class Distal_Probability Distal_Log_Odds
                      CI_Lower_Log_Odds CI_Upper_Log_Odds
                      CI_Lower_Probability CI_Upper_Probability
            }; APPEND;
            CLOSE _log_odds_this_group;
        %END;      
        %IF %EVAL(&is_categorical=1) %THEN %DO; 
            /* This case is different from the others because we have to loop through
               the categories and get estimates for each category. */
            Category_Level_Values = Z[><]:Z[<>];  
               /* The minimum to maximum category numbers.  They should usually be 
                  1 through the number of categories, but we might have to deal with the 
                  possibility that they might not be. */
            Class_Level_Values = 1:num_classes; 
            Outcome_Category  = COLVEC((REPEAT(Category_Level_Values,NCOL(Class_Level_Values),1))`);
            Class = COLVEC((REPEAT(Class_Level_Values,NCOL(Category_Level_Values),1))); 
            Distal_Prob = J(NROW(Outcome_Category),1,.);
            Distal_Std_Error_For_Prob = J(NROW(Outcome_Category),1,.); 
               /* The above two lines create a table like this :
                        Outcome_Category   Class     
                        1                    1           
                        1                    2           
                        1                    3           
                        2                    1           
                        2                    2           
                        2                    3           */                   
            DO This_Category = Z[><] TO Z[<>];
                Z_This_Category = 1*(Z=This_Category);
                Distal_Prob_This_Category = J(num_classes,1,.); 
                Distal_Std_Error_This_Category = J(num_classes,1,.);
                Cov_Matrix_Linear_Pred_This_Cat = J(num_classes,num_classes,.);
                CALL Estimate_Distal_Mean_And_SE( num_classes,  /* input */
                                                    N,  /* input */
                                                    Chosen_Weights,  /* input */
                                                    Z_This_Category,  /* input */
                                                    1, 0, 0, /* treat as identity link for purposes of getting a direct estimate for the proportion and symmetric standard errors for it */
                                                    Distal_Prob_This_Category,  /* output */
                                                    Distal_Std_Error_This_Category, /* output */
                                                    Cov_Matrix_Distal_Probs_This_Cat); 
                Distal_Prob[LOC(Outcome_Category=This_Category)] = Distal_Prob_This_Category;
                Distal_Std_Error_For_Prob[LOC(Outcome_Category=This_Category)] = Distal_Std_Error_This_Category;
            END;                
            IF (SUM(Distal_Prob<0)>0) THEN DO;
                Distal_Prob[LOC(Distal_Prob<0)] = .;
                Distal_Std_Error_For_Prob[LOC(Distal_Prob<0)] = .;
            END;
            IF (SUM(Distal_Prob>1)>0) THEN DO;
                Distal_Prob[LOC(Distal_Prob>1)] = .;
                Distal_Std_Error_For_Prob[LOC(Distal_Prob>1)] = .;
            END;
            CREATE _estimates_this_group VAR {
                Class Outcome_Category Distal_Prob Distal_Std_Error_For_Prob
            }; APPEND;
            CLOSE _estimates_this_group;
        %END;       
        /* Now we are done with estimates and standard errors, and it is time to 
           start calculating significance tests. */
        /* Calculate p-values for contrasts using the covariance of the BCH-weighted means. 
         We will handle continuous, count, and binary together in this part, but will
         tell the helper function what kind they are, so that it can use the correct link.
         Like Latent GOLD, we will do the test with the identity link for the continuous 
         outcomes, logit link for the binary outcomes, and log link for the count outcomes. 
         The categorical case is a little trickier and is handled separately later. */     
        %IF %EVAL((&is_continuous=1) | (&is_count=1) | (&is_binary=1)) %THEN %DO; 
            /* Get the Linear_Predictor and Cov_Matrix_Linear_Predictor that are
               correct for this distribution. */        
            Linear_Predictor = J(num_classes,1,.);
            Distal_Std_Error = J(num_classes,1,.);
            Cov_Matrix_Linear_Predictor = J(num_classes,num_classes,.);
            CALL Estimate_Distal_Mean_And_SE(num_classes,  /* input */
                                               N,  /* input */
                                               Chosen_Weights,  /* input */
                                               Z,  /* input */
                                               &is_continuous, /* input */   /* to use identity link */
                                               &is_count, /* input */    /* to use log link */
                                               &is_binary, /* input */   /* to use logit link */
                                               Linear_Predictor,  /* output */
                                               Distal_Std_Error, /* output */
                                               Cov_Matrix_Linear_Predictor); /* output */     
            
            /* Now we have the correct covariance matrix for the linear predictor vector, which is 
               defined here as the link function applied to each the distal means.  This covariance
               matrix is stored in Cov_Matrix_Linear_Predictor.  We will use it to do significance 
               tests on the differences between linear predictors (transformed distal means) for 
               each class.  This can be done using matrix algebra.  
               Consider the continuous case for simplicity so that the distal mean
               and the linear predictor are the same thing (identity link).  Then the estimates for
               the distal mean parameters are a vector,  say maybe [4.2, 1.9, 3.8] for classes 1, 2, 
               and 3, stored in Linear_Predictor, and their covariance matrix is in 
               Cov_Matrix_Linear_Predictor.  We can calculate a linear contrast by taking the inner 
               product of the mean vector with a vector L; for instance, 
               E = L` * mu = [-1, +1, 0]` * [4.2, 1.9, 3.8] = 1.9 - 4.2, the difference between classes 2 and 1.
               (The ` sign is SAS symbol for transpose.) 
               The variance of this contrast E is the quadratic form L`*Cov_Matrix_Linear_Predictor*L.
               The Wald statistic is the square of E, divided by its variance.  It has 1 degree of 
               freedom if 1 parameter is being compared to 1 other parameter.  We get the p-value for 
               the Wald statistic by comparing it to a chi-squared distribution.            */                                   
            /* Calculate specific contrasts */
            Contrasts = J(num_classes*(num_classes-1)/2,num_classes,0);
            FirstClassNames = J(num_classes*(num_classes-1)/2,1,0);    
            SecondClassNames = J(num_classes*(num_classes-1)/2,1,0);    
            Estimate = J(num_classes*(num_classes-1)/2,1,0);
            Std_Error = J(num_classes*(num_classes-1)/2,1,0);
            Wald_Statistic = J(num_classes*(num_classes-1)/2,1,0);
            DF = J(num_classes*(num_classes-1)/2,1,0);
            P_Value = J(num_classes*(num_classes-1)/2,1,0);
            row = 0;
            DO FirstClass = 1 TO (num_classes-1);
                DO SecondClass = (FirstClass+1) TO num_classes;
                    row = row + 1;
                    Contrasts[row,FirstClass] = -1;
                    Contrasts[row,SecondClass] = +1; 
                    FirstClassNames[row] = FirstClass;
                    SecondClassNames[row] = SecondClass;
                END;
            END; 
            %IF %EVAL((&is_continuous=1)) %THEN %DO;
                Name = "Difference in Means";
            %END;
            %IF %EVAL((&is_count=1)) %THEN %DO;
                Name = "Difference in Log Means";
            %END; 
            %IF %EVAL((&is_binary=1)) %THEN %DO;
                Name = "Difference in Log Odds";
            %END; 
            Name = CONCAT(Name, ": Class ",CHAR(SecondClassNames)," versus Class ",CHAR(FirstClassNames));
            DO row = 1 to NROW(Contrasts); 
                Estimate[row] =  Contrasts[row,]*Linear_Predictor;
                Std_Error[row] = SQRT(Contrasts[row,]*Cov_Matrix_Linear_Predictor*Contrasts[row,]`);
                   /* square root of the variance */
                Wald_Statistic[row] = (Estimate[row]/Std_Error[row])**2;
                DF[row] = 1;
                P_Value[row] = 1-PROBCHI(Wald_Statistic[row],1);
            END;  
            /* Calculate omnibus test.  "Omnibus" means the test of whether all of the means 
            are equal.  We don't care about estimates here, only a test.  That is because we're 
            not asking about the difference between class A and class B, but the differences
            between all the classes.  Instead of a vector L, we have a matrix L containing 
            the largest number of rows that would not lead to a singular L * Cov_Matrix_Linear_Predictor * L`,
            for example,
            [-1, 1, 0,
             -1, 0, 1] 
             for 3 classes.             */
            Omnibus_DF = num_classes-1; 
            rows = 1:Omnibus_DF;
            Omnibus_Estimate_Vector = Contrasts[rows,]*Linear_Predictor;
            Omnibus_Error_Matrix = Contrasts[rows,]*Cov_Matrix_Linear_Predictor*Contrasts[rows,]`;
            Omnibus_Wald_Statistic = Omnibus_Estimate_Vector` * INV(Omnibus_Error_Matrix) * Omnibus_Estimate_Vector;
            Omnibus_P_Value = 1-PROBCHI(Omnibus_Wald_Statistic,Omnibus_DF);
            Name = Name // "Omnibus Test";
            Estimate = Estimate // .;
            Std_Error = Std_Error // .;
            Wald_Statistic = Wald_Statistic // Omnibus_Wald_Statistic;
            DF = DF // Omnibus_DF;
            P_Value = P_Value // Omnibus_P_Value;
            /* Create output dataset. */
            CREATE _tests_this_group VAR { 
                Name Estimate Std_Error 
                Wald_Statistic DF P_Value  
            }; APPEND;
            CLOSE _tests_this_group;
        %END;
        %IF %EVAL(&is_categorical=1) %THEN %DO; 
        /* I had to write the code for categorical outcomes separate because it uses a different formula.
           I adopted this and the other formulas from the sandwich formula used in the documentation of 
           SAS PROC SURVEYLOGISTIC, even though we do not call this PROC.  */
            Total_Omnibus_DF = 0;
            Total_Omnibus_Wald_Statistic = 0;
            min_cat = Z[><]; /* smallest category number;  most users will use 1 here */
            max_cat = z[<>]; /* largest category number */
            num_cats = max_cat - min_cat + 1;
            cats = min_cat:max_cat; 
            G = J(num_classes*(num_cats-1),num_classes*(num_cats-1),0);
            DO i = 1 TO N;
                e_i = J(num_classes*(num_cats-1),1,.);
                row = 0;
                DO c = 1 TO num_classes;
                    DO This_Category_Index = 1 TO (num_cats-1); 
                        row = row + 1;                    
                        This_Category = cats[This_Category_Index];
                        Z_i_This_Category = 1*(Z[i]=This_Category);
                        Distal_Prob_This_Category = ((Chosen_Weights[,c]#(1*(Z=This_Category)))[+])/(Chosen_Weights[+,c]); 
                        e_i[row] = (Chosen_Weights[i,c])*
                                                    (Z_i_This_Category - Distal_Prob_This_Category);
                    END;
                END;
                G = G + (e_i)*(e_i)`;
            END;   /* G is now the empirical covariance matrix for Z. */
            Q = J(num_classes*(num_cats-1),num_classes*(num_cats-1),0); 
            DO c = 1 TO num_classes;
                Pi_Vector_This_Class = J(num_cats-1,1,.);
                Diag_Pi_Vector_This_Class = J(num_cats-1,num_cats-1,0);
                DO This_Category_Index = 1 TO (num_cats-1); 
                    This_Category = cats[This_Category_Index];
                    Z_This_Category = 1*(Z=This_Category);
                    Distal_Prob_This_Class_And_Cat = ((Chosen_Weights[,c]#Z_This_Category)[+])/(Chosen_Weights[+,c]);
                    Pi_Vector_This_Class[This_Category_Index] = Distal_Prob_This_Class_And_Cat;
                    Diag_Pi_Vector_This_Class[This_Category_Index,This_Category_Index] = Distal_Prob_This_Class_And_Cat;
                END;
                DO i = 1 TO N;
                    new_block_contrib = Chosen_Weights[i,c]*(Diag_Pi_Vector_This_Class - Pi_Vector_This_Class*Pi_Vector_This_Class`);
                    places = ((c-1)*(num_cats-1)+1):(c*(num_cats-1));
                    Q[places,places] = Q[places,places] + new_block_contrib;
                END;
            END; 
            /* Q is now the model-based covariance matrix for the distal linear predictors. */
            Qinv = INV(Q);  
            Cov_Matrix_Linear_Predictor = ((num_classes*N-1)/(num_classes*N-num_classes))*(Qinv*G*Qinv); 
                         /* sandwich formula */            
            Linear_Predictor = J(num_classes*(num_cats-1),1,.);
            row = 0;
            DO c = 1 TO num_classes;
                DO This_Category_Index = 1 TO (num_cats-1); 
                    row = row + 1;                    
                    This_Category = cats[This_Category_Index];
                    Z_This_Category = 1*(Z=This_Category);
                    Z_Baseline = 1*(Z=max_cat);
                    Distal_Prob_This_Category = ((Chosen_Weights[,c]#Z_This_Category)[+])/(Chosen_Weights[+,c]);
                    Distal_Prob_Baseline = ((Chosen_Weights[,c]#Z_Baseline)[+])/(Chosen_Weights[+,c]);
                    Linear_Predictor[row] = LOG(Distal_Prob_This_Category+1E-20)-LOG(Distal_Prob_Baseline+1e-20);
                END;
            END;
            /* Calculate omnibus contrasts.  I decided not to calculate estimates in the 
            categorical case, but only do the omnibus test.  Otherwise we would need to 
            provide a test for each pair of classes within each response category, which 
            feels like too many null hypotheses to me. */
            Contrasts = J((num_classes-1) * (num_cats-1),num_classes*(num_cats-1),0);
            row = 0;
            DO c = 2 TO num_classes;
                DO This_Category_Index = 1 TO (num_cats-1); 
                    row = row + 1;                    
                    Contrasts[row,This_Category_Index] = +1;
                    Contrasts[row,(c-1)*(num_cats-1)+This_Category_Index] = -1;
                END;
            END;
            Omnibus_Estimate_Vector = Contrasts*Linear_Predictor;
            Omnibus_Error_Matrix = Contrasts*Cov_Matrix_Linear_Predictor*Contrasts`;
                  /* the symbol ` means transpose */
            Wald_Statistic = Omnibus_Estimate_Vector` * INV(Omnibus_Error_Matrix) * Omnibus_Estimate_Vector;
            Name = "Omnibus Test";  
            DF = (num_classes-1) * (num_cats-1);
            P_Value = 1-PROBCHI(Wald_Statistic,DF);
            IF (SUM(Distal_Prob=.)>0) THEN DO;
                Wald_Statistic = .;
                P_Value = .;
            END;
            CREATE _tests_this_group VAR { 
                Name 
                Wald_Statistic DF P_Value  
            }; APPEND;
            CLOSE _tests_this_group;        
        %END;
    QUIT;  
    %IF %EVAL(&is_categorical=1) %THEN %DO;
        PROC SORT DATA=_estimates_this_group;
            BY Class Outcome_Category;
        RUN;
    %END;
    %IF %EVAL(&is_proportional_assignment = 1) %THEN %DO;
        %IF %EVAL(&is_naive_adjustment_method=1) %THEN %DO;
            TITLE4 "Estimates using Unadjusted Proportional Weighting"; 
        %END; %ELSE %DO;
            TITLE4 "Estimates using BCH Proportional Weighting"; 
        %END;
    %END; %ELSE %DO;
        %IF %EVAL(&is_naive_adjustment_method=1) %THEN %DO;
            TITLE4 "Estimates using Unadjusted Modal Weighting"; 
        %END; %ELSE %DO;
            TITLE4 "Estimates using BCH Modal Weighting"; 
        %END;
    %END;
    PROC PRINT DATA=_estimates_this_group NOOBS; 
    RUN; 
    %IF %EVAL(&is_binary=1) %THEN %DO;
        TITLE4 "Confidence Intervals for Probabilities"; 
        PROC PRINT DATA=_log_odds_this_group NOOBS; 
        RUN; 
    %END;
    TITLE4 "Wald Chi-Squared Tests"; 
    PROC PRINT DATA=_tests_this_group NOOBS; 
    RUN;
%MEND Distal_NoGroup_BCH;

